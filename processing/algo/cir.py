import os, sys
from warnings import warn

sys.path.append(os.path.dirname(os.path.dirname(os.path.realpath(__file__))))

import numpy as np
from scipy.signal import upfirdn
from config import CIR_INTERP_B, CIR_LEN, CIR_UPSAMPLE, CIR_ALIGN_TO


def interpolate_cir(h_in, sps):
    h_in = np.array(h_in)
    assert h_in.ndim == 1, 'Must be 1 dimensional CIR input'
    # rolloff = 0.25  # Rolloff factor
    # span = 16  # Filter span in symbols
    assert isinstance(sps, int)
    assert sps > 1

    # TODO: This is pre-calculated by MATLAB with above rolloff, span and sps params. Need to port to Python
    # In MATLAB: generated by: b = rcosdesign(rolloff, span, sps);
    assert sps in CIR_INTERP_B.keys(), f'Please generate {sps}X upsampling coefficients with MATLAB using ' \
                                       f'rcosdesign(rolloff, span, sps) and save in config.py/CIR_INTERP_B'
    b = CIR_INTERP_B[sps]
    powb = np.sqrt(np.mean(np.abs(b) ** 2))
    b = b / powb
    x = upfirdn(x=h_in, h=b, up=sps)
    cutx = int(np.ceil((len(b) - sps) / 2))

    x = x[cutx - 1:-cutx]
    pin = np.sqrt(np.mean(np.abs(h_in) ** 2))
    pout = np.sqrt(np.mean(np.abs(x) ** 2))
    h = x * pin / pout
    return h


def extract_fp(synced_ap_data):
    # Accepts data structure from load.sync.reformat_sync_ap_data
    assert isinstance(synced_ap_data, dict)
    interp_cir = synced_ap_data['interp_cir']
    fpis = np.round(synced_ap_data['fp_idxs'] * interp_cir).astype(np.int64)
    cirs = synced_ap_data['cir']
    n_packets, _, n_chips = cirs.shape

    # Extract first peak CIR
    # https://numpy.org/doc/stable/reference/arrays.indexing.html#integer-array-indexing
    rows = np.tile(np.arange(n_packets)[:, None], (1, n_chips))
    depths = np.tile(np.arange(n_chips), (n_packets, 1))
    cirs_fp = cirs[rows, fpis, depths]
    # Correct SFD for FP
    cirs_fp = correct_sfd(cir_data=cirs_fp, sfd_data=synced_ap_data['sfd_data'])

    # Get Adjacent Data for analysis, and correct SFD for them
    cirs_adj = np.zeros([cirs_fp.shape[0], interp_cir * 2 + 1, cirs_fp.shape[1]], dtype=np.complex)
    for i in range(interp_cir, 0, -1):
        cirs_prev_tap = cirs[rows, fpis - i, depths]
        cirs_adj[:, interp_cir - i] = correct_sfd(cir_data=cirs_prev_tap, sfd_data=synced_ap_data['sfd_data'])

    cirs_adj[:, interp_cir] = cirs_fp

    for i in range(1, interp_cir + 1):
        cirs_next_tap = cirs[rows, fpis + i, depths]
        cirs_adj[:, interp_cir + i] = correct_sfd(cir_data=cirs_next_tap, sfd_data=synced_ap_data['sfd_data'])

    # Align and correct full CIR taps
    cirs_align = align_cir(cirs, synced_ap_data['fp_idxs'])
    for i in range(cirs_align.shape[1]):
        tap = cirs_align[:, i]
        cirs_align[:, i] = correct_sfd(cir_data=tap, sfd_data=synced_ap_data['sfd_data'])

    synced_ap_data['cir_fp'] = cirs_fp
    synced_ap_data['cir_adj'] = cirs_adj
    synced_ap_data['cir_sync'] = cirs_align
    return synced_ap_data


def correct_sfd(cir_data, sfd_data):
    assert isinstance(cir_data, np.ndarray)
    assert isinstance(sfd_data, np.ndarray)

    # cir: n_packets x 8 antennas
    # sfd: n_packets x 8 antennas
    assert cir_data.ndim == 2 and sfd_data.ndim == 2, 'CIR must contain fp only!'
    assert cir_data.shape == sfd_data.shape

    rcphase = np.exp(-1.0j * sfd_data)
    cir_corrected = cir_data * rcphase

    assert cir_corrected.shape == cir_data.shape
    return cir_corrected


def calc_0deg_offset(cir_data):
    assert isinstance(cir_data, np.ndarray)
    # cir_data: n_packets x 8 antennas
    assert cir_data.ndim == 2, 'CIR must contain fp only!'

    phasor0 = cir_data[:, 0] / np.abs(cir_data[:, 0])
    packets = cir_data / phasor0[:, None]

    warn('Hardcoded to use last 1000 packets as calibration data')
    pak_mean = np.mean(packets[-1000:], axis=0)
    zero_deg_offset = pak_mean / np.abs(pak_mean)
    return zero_deg_offset


def calc_adj_0deg_offset(cir_data_adj):
    assert isinstance(cir_data_adj, np.ndarray)
    # cir_data: n_packets x n taps x 8 antennas
    assert cir_data_adj.ndim == 3, 'Adjacent CIR must contain multiple taps!'
    phasor0 = cir_data_adj[:, :, 0] / np.abs(cir_data_adj[:, :, 0])
    packets = cir_data_adj / phasor0[:, :, None]
    pak_mean = np.mean(packets[-1000:], axis=0)
    zero_deg_offset_adj = pak_mean / np.abs(pak_mean)
    return zero_deg_offset_adj


def correct_cir(cir_data, zero_deg_offset):
    assert isinstance(cir_data, np.ndarray)
    assert isinstance(zero_deg_offset, np.ndarray)
    # cir_data: n_packets x 8 antennas
    # zero_deg_offset: n_packets
    assert cir_data.ndim == 2, 'CIR must contain fp only!'
    assert zero_deg_offset.ndim == 1, '0 degree offset must be 1-d!'
    assert cir_data.shape[1] == zero_deg_offset.shape[0], 'Num of antennas does not equal!'

    # Correct zero degree
    cir_data_corrected = cir_data / zero_deg_offset
    # Offset phase by antenna 0 phase
    antenna_0_phase = np.angle(cir_data_corrected[:, 0])
    cir_data_corrected = cir_data_corrected * np.exp(-1j * antenna_0_phase)[:, None]
    return cir_data_corrected


def correct_adj_cir(cir_data_adj, zero_deg_offset_adj):
    assert isinstance(cir_data_adj, np.ndarray)
    assert isinstance(zero_deg_offset_adj, np.ndarray)
    # cir_data: n_packets x n_taps x 8 antennas
    # zero_deg_offset: n_packets x n_taps
    assert cir_data_adj.ndim == 3, 'Adjacent CIR must contain multiple taps!'
    assert zero_deg_offset_adj.ndim == 2, '0 degree adjacent offset must be 2-d!'
    assert cir_data_adj.shape[1] == zero_deg_offset_adj.shape[0], 'Num of antennas does not equal!'

    # Correct zero degree
    cir_data_corrected = cir_data_adj / zero_deg_offset_adj
    # Offset phase by antenna 0 phase
    antenna_0_phase_adj = np.angle(cir_data_corrected[:, :, 0])
    cir_data_corrected = cir_data_corrected * np.exp(-1j * antenna_0_phase_adj)[:, :, None]
    return cir_data_corrected


def align_cir(cir, fpi, align_to=CIR_ALIGN_TO, cir_upsample=CIR_UPSAMPLE):
    """
    Align CIR given fpi
    :param cir: CIR matrix in n_pak x n_tap x n_ant
    :param fpi: FPI matrix in n_pak x n_ant. Index is for before up-sampling (1ns per tap)
    :param align_to: Align FPI to this index. Index is for before up-sampling (1ns per tap)
    :param cir_upsample: Number of times the CIR is upsampled
    :return: aligned CIR in n_pak x n_tap x n_ant
    """
    assert isinstance(cir, np.ndarray)
    assert cir.dtype == np.complex
    assert cir.ndim == 3, 'cir must be in n_pak x n_tap x n_ant'
    assert cir.shape[1] == CIR_LEN * cir_upsample
    assert cir.shape[2] == 8

    assert isinstance(fpi, np.ndarray)
    assert fpi.dtype == np.float, 'fpi must not be upsampled index!'
    assert fpi.ndim == 2, 'fpi must be in n_pak x n_ant'
    assert fpi.shape[0] == cir.shape[0]
    assert fpi.shape[1] == cir.shape[2]

    roll = -1 * np.round((fpi - align_to) * cir_upsample).astype(np.int64)
    # https://stackoverflow.com/questions/20360675/roll-rows-of-a-matrix-independently
    paks, taps, ants = np.ogrid[:cir.shape[0], :cir.shape[1], :cir.shape[2]]
    # Use always a negative shift, so that column_indices are valid
    roll[roll < 0] += cir.shape[1]
    taps = taps - roll[:, None]

    return cir[paks, taps, ants]
